> Node.jsä½¿ç”¨äº‹ä»¶é©±åŠ¨çš„æ¶æ„ï¼Œè®¸å¤šè¿æ¥å¯ä»¥å¹¶è¡Œå¤„ç†ã€‚æ¯ä¸€ä¸ªè¿æ¥éƒ½ä¼šè§¦å‘ä¸€ä¸ªå›è°ƒ,è¿™ä¸ä»Šå¤©ä½¿ç”¨ OS çº¿ç¨‹çš„æ›´å¸¸è§å¹¶å‘æ¨¡å‹å½¢æˆäº†å¯¹æ¯”ã€‚
> åŸºäºçº¿ç¨‹çš„ç½‘ç»œæ•ˆç‡ç›¸å¯¹ä½ä¸‹ï¼Œä½¿ç”¨èµ·æ¥éå¸¸å›°éš¾ã€‚æ­¤å¤–ï¼ŒNode.js çš„ç”¨æˆ·ä¸å¿…æ‹…å¿ƒæ­»é”è¿‡ç¨‹ï¼Œå› ä¸ºæ²¡æœ‰é”ã€‚Node ä¸­å‡ ä¹æ²¡æœ‰å‡½æ•°ç›´æ¥æ‰§è¡Œ I/O æ“ä½œï¼Œå› æ­¤è¿›ç¨‹ä»ä¸é˜»å¡ã€‚

https://www.codenong.com/34855352/

æˆ‘çŸ¥é“Node.jsä½¿ç”¨å•çº¿ç¨‹å’Œäº‹ä»¶å¾ªç¯æ¥å¤„ç†è¯·æ±‚ï¼Œä¸€æ¬¡åªå¤„ç†ä¸€ä¸ª(éé˜»å¡)ã€‚ ä½†æ˜¯ï¼Œå¦‚ä½•å·¥ä½œï¼Œè®©æˆ‘ä»¬è¯´10,000ä¸ªå¹¶å‘è¯·æ±‚ã€‚ äº‹ä»¶å¾ªç¯å°†å¤„ç†æ‰€æœ‰è¯·æ±‚ï¼Ÿ è¿™ä¸ä¼šèŠ±å¤ªé•¿æ—¶é—´å—ï¼Ÿ

æˆ‘æ— æ³•ç†è§£å®ƒæ˜¯å¦‚ä½•æ¯”å¤šçº¿ç¨‹WebæœåŠ¡å™¨æ›´å¿«çš„ã€‚ æˆ‘çŸ¥é“å¤šçº¿ç¨‹WebæœåŠ¡å™¨çš„èµ„æº(å†…å­˜ï¼ŒCPU)ä¼šæ›´åŠ æ˜‚è´µï¼Œä½†å®ƒä¸ä¼šæ›´å¿«å—ï¼Ÿ æˆ‘å¯èƒ½é”™äº†; è¯·è§£é‡Šè¿™ä¸ªå•çº¿ç¨‹å¦‚ä½•åœ¨å¤§é‡è¯·æ±‚ä¸­æ›´å¿«ï¼Œä»¥åŠåœ¨å¤„ç†å¤§é‡è¯·æ±‚(ä¾‹å¦‚10,000)æ—¶å®ƒé€šå¸¸ä¼šåšä»€ä¹ˆ(åœ¨é«˜çº§åˆ«)ã€‚

- å¤šçº¿ç¨‹ç½‘ç»œåº”ç”¨ç¨‹åºå¤„ç†ä¸Šè¿°å·¥ä½œè´Ÿè½½ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š
```
request â”€â”€> spawn thread
							â””â”€â”€> wait for database request
										â””â”€â”€> answer request
request â”€â”€> spawn thread
							â””â”€â”€> wait for database request
										â””â”€â”€> answer request
request â”€â”€> spawn thread
							â””â”€â”€> wait for database request
										â””â”€â”€> answer request
```
å› æ­¤ï¼Œçº¿ç¨‹èŠ±è´¹å¤§éƒ¨åˆ†æ—¶é—´ä½¿ç”¨0ï¼…CPUç­‰å¾…æ•°æ®åº“è¿”å›æ•°æ®ã€‚åœ¨è¿™æ ·åšæ—¶ï¼Œä»–ä»¬å¿…é¡»åˆ†é…ä¸€ä¸ªçº¿ç¨‹æ‰€éœ€çš„å†…å­˜ï¼Œå…¶ä¸­åŒ…å«ä¸€ä¸ªå®Œå…¨ç‹¬ç«‹çš„ç¨‹åºå †æ ˆï¼Œæ¯ä¸ªçº¿ç¨‹ç­‰ã€‚
æ­¤å¤–ï¼Œä»–ä»¬å¿…é¡»å¯åŠ¨ä¸€ä¸ªçº¿ç¨‹è™½ç„¶ä¸åƒå¯åŠ¨ä¸€ä¸ªå®Œæ•´çš„è¿›ç¨‹é‚£ä¹ˆæ˜‚è´µä½†ä»ç„¶ä¸å®Œå…¨å»‰ä»·ã€‚

- å•çº¿ç¨‹äº‹ä»¶å¾ªç¯
æ¯ä¸ªè¯·æ±‚ä»å°†è·å¾—ä¸å¤šçº¿ç¨‹åº”ç”¨ç¨‹åºç›¸åŒçš„CPUæ—¶é—´ï¼Œä½†æˆ‘ä»¬ä¸éœ€è¦å¯åŠ¨çº¿ç¨‹ã€‚æ‰€ä»¥æˆ‘ä»¬è¿™æ ·åšï¼š
```
request â”€â”€> make database request
request â”€â”€> make database request
request â”€â”€> make database request
database request complete â”€â”€> send response
database request complete â”€â”€> send response
database request complete â”€â”€> send response
```
å®é™…ä¸Šï¼Œè¿™ä¸¤ç§æ–¹æ³•éƒ½è¿”å›å¤§è‡´ç›¸åŒå»¶è¿Ÿçš„æ•°æ®ï¼Œå› ä¸ºå®ƒæ˜¯ä¸»å¯¼å¤„ç†çš„æ•°æ®åº“å“åº”æ—¶é—´ã€‚

è¿™é‡Œçš„ä¸»è¦ä¼˜ç‚¹æ˜¯æˆ‘ä»¬ä¸éœ€è¦ç”Ÿæˆä¸€ä¸ªæ–°çº¿ç¨‹ï¼Œæ‰€ä»¥æˆ‘ä»¬ä¸éœ€è¦åšå¾ˆå¤šå¾ˆå¤šmallocï¼Œè¿™ä¼šå‡æ…¢æˆ‘ä»¬çš„é€Ÿåº¦ã€‚

## [Node.jsç‰¹æ€§](https://nodejs.dev/learn)
A Node.js app is run in a single process, without creating a new thread for every request. 
Node.js provides a set of asynchronous I/O primitives in its standard library that prevent JavaScript code from blocking and generally, 
libraries in Node.js are written using non-blocking paradigms, making blocking behavior the exception rather than the norm.

å¸¸è§„çš„Nodeåº”ç”¨éƒ½æ˜¯ä»¥å•ä¸ªè¿›ç¨‹çš„å½¢å¼è¿è¡Œï¼Œä¸ä¼šä¸ºæ¯ä¸€ä¸ªè¯·æ±‚éƒ½åˆ›å»ºä¸€ä¸ªçº¿ç¨‹ã€å“ªäº›ç¼–ç¨‹è¯­è¨€ä¼šä¸ºæ¯ä¸ªè¯·æ±‚åˆ›å»ºçº¿ç¨‹ï¼Ÿã€‘ã€‚
Node.jsåœ¨å…¶æ ‡å‡†åº“ä¸­æä¾›äº†å¤§é‡çš„å¼‚æ­¥çš„æ–¹æ³•æ¥é¿å…jsä»£ç åœ¨è¿è¡Œæ—¶å‘ç”Ÿé˜»å¡ã€å¦‚æœä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼ˆäº‹ä»¶è½®è¯¢çº¿ç¨‹ï¼‰æˆ–è€…ä»»åŠ¡ï¼ˆå·¥ä½œçº¿ç¨‹ï¼‰éœ€è¦è€—è´¹å¾ˆé•¿æ—¶é—´ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œé˜»å¡â€ã€‚ 
å½“ä¸€ä¸ªçº¿ç¨‹åœ¨å¤„ç†æŸä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚æ—¶è¢«é˜»å¡äº†ï¼Œå®ƒå°±æ— æ³•å¤„ç†å…¶å®ƒå®¢æˆ·ç«¯çš„è¯·æ±‚äº†ã€‚ã€‘
ã€è¿™äº›åº“éƒ½éµå¾ªéé˜»å¡çš„èŒƒå¼ã€‘ä½¿é˜»å¡è¡Œä¸ºæˆä¸ºå¼‚å¸¸è€Œä¸æ˜¯å¸¸æ€

When Node.js performs an I/O operation, like reading from the network, accessing a database or the filesystem, instead of blocking the thread and wasting CPU cycles waiting, Node.js will resume the operations when the response comes back.

å½“Node.jsæ‰§è¡ŒI/Oæ“ä½œã€è¯»å–ç½‘ç»œè¯·æ±‚ï¼Œå­˜å–æ•°æ®åº“æˆ–è€…æ–‡ä»¶ç³»ç»Ÿã€‘ï¼Œå®ƒçš„å¤„ç†æ–¹å¼éƒ½ä¸ä¼šé˜»å¡çº¿ç¨‹é€ æˆCPUç­‰å¾…ï¼Œå®ƒæ˜¯ä¼šç­‰å¼‚æ­¥æ“ä½œè¿”å›æ‰§è¡Œç»“æœç„¶åæ¢å¤ä¹‹å‰çš„æ“ä½œã€‚ã€å¦‚ä½•å®ç°ï¼Ÿ- å›è°ƒå‡½æ•°ã€‘

Being blocking is the exception, and this is why JavaScript is based so much on callbacks, and more recently on promises and async/await.
JavaScriptå¦‚æœé˜»å¡äº†é‚£å°±æ˜¯å‡ºç°äº†å¼‚å¸¸ï¼Œè¿™ä¹Ÿå°±æ˜¯å®ƒä¸ºä»€ä¹ˆä¼šåŸºäºé‚£ä¹ˆå¤šçš„å›è°ƒå‡½æ•°ï¼ŒåŒ…æ‹¬åæ¥å‡ºç°çš„promiseå’Œasync/awaitã€å›è°ƒå‡½æ•°æ˜¯å¦‚ä½•é¿å…äº†é˜»å¡ï¼Ÿã€‘

This allows Node.js to handle thousands of concurrent connections with a single server without introducing the burden of managing thread concurrencyï¼Œ 
which could be a significant source of bugs
è¿™å°±å…è®¸Node.jså•ä¸ªæœåŠ¡å°±å¯ä»¥å¤„ç†å¤§é‡çš„å¹¶å‘è¿æ¥, è€Œä¸ç”¨è€ƒè™‘ç”¨å¤šçº¿ç¨‹æ¥å¤„ç†å¹¶å‘ã€å“ªäº›è¯­è¨€åœ¨ç”¨å¤šçº¿ç¨‹å¤„ç†å¹¶å‘ï¼Ÿæœ‰ä»€ä¹ˆé—®é¢˜ï¼Ÿã€‘


[Don't block event loop](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/)

Node.js æœ‰ä¸¤ç§ç±»å‹çš„çº¿ç¨‹ï¼šä¸€ä¸ªäº‹ä»¶å¾ªç¯çº¿ç¨‹å’Œ k ä¸ªå·¥ä½œçº¿ç¨‹ã€‚ 
äº‹ä»¶å¾ªç¯è´Ÿè´£ JavaScript å›è°ƒå’Œéé˜»å¡ I/Oï¼Œå·¥ä½œçº¿ç¨‹æ‰§è¡Œä¸ C++ ä»£ç å¯¹åº”çš„ã€å®Œæˆå¼‚æ­¥è¯·æ±‚çš„ä»»åŠ¡ï¼ŒåŒ…æ‹¬é˜»å¡ I/O å’Œ CPU å¯†é›†å‹å·¥ä½œã€‚ 
è¿™ä¸¤ç§ç±»å‹çš„çº¿ç¨‹ä¸€æ¬¡éƒ½åªèƒ½å¤„ç†ä¸€ä¸ªæ´»åŠ¨ã€‚ å¦‚æœä»»æ„ä¸€ä¸ªå›è°ƒæˆ–ä»»åŠ¡éœ€è¦å¾ˆé•¿æ—¶é—´ï¼Œåˆ™è¿è¡Œå®ƒçš„çº¿ç¨‹å°†è¢« é˜»å¡ã€‚ å¦‚æœä½ çš„åº”ç”¨ç¨‹åºå‘èµ·é˜»å¡çš„å›è°ƒæˆ–ä»»åŠ¡ï¼Œåœ¨å¥½çš„æƒ…å†µä¸‹è¿™å¯èƒ½åªä¼šå¯¼è‡´ååé‡ä¸‹é™ï¼ˆå®¢æˆ·ç«¯/ç§’ï¼‰ï¼Œè€Œåœ¨æœ€åæƒ…å†µä¸‹å¯èƒ½ä¼šå¯¼è‡´å®Œå…¨æ‹’ç»æœåŠ¡ã€‚

è¦ç¼–å†™é«˜ååé‡ã€é˜² DoS æ”»å‡»çš„ web æœåŠ¡ï¼Œæ‚¨å¿…é¡»ç¡®ä¿ä¸ç®¡åœ¨è‰¯æ€§æˆ–æ¶æ„è¾“å…¥çš„æƒ…å†µä¸‹ï¼Œæ‚¨çš„äº‹ä»¶å¾ªç¯çº¿ç¨‹å’Œæ‚¨çš„å·¥ä½œçº¿ç¨‹éƒ½ä¸ä¼šé˜»å¡ã€‚

è¯·è®°ä½ï¼Œäº‹ä»¶å¾ªç¯çº¿ç¨‹åªè´Ÿè´£åè°ƒå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œè€Œä¸æ˜¯ç‹¬è‡ªæ‰§è¡Œå®Œæ‰€æœ‰ä»»åŠ¡ã€‚ å¯¹ä¸€ä¸ªå¤æ‚çš„ä»»åŠ¡ï¼Œæœ€å¥½æŠŠå®ƒä»äº‹ä»¶å¾ªç¯çº¿ç¨‹è½¬ç§»åˆ°å·¥ä½œçº¿ç¨‹æ± ä¸Šã€‚

> å…·ä½“event loopå¦‚ä½•å·¥ä½œï¼ŒæŸ¥çœ‹[**libuv**](./libuv.md)

## ä¸»è¿›ç¨‹ä¸­çš„event loopé˜»å¡
```js
const http = require('http');

const longComputation = () => {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) {
    sum += i;
  };
  return sum;
};

const server = http.createServer();

server.on('request', (req, res) => {
  if (req.url === '/compute') {
    const sum = longComputation();
    return res.end(`Sum is ${sum}`);
  } else {
    res.end('Ok')
  }
});

server.listen(3000);
```
This program has a big problem; when the the /compute endpoint is requested, 
the server will not be able to handle any other requests because the event loop is busy with the long for loop operation.

We first move the whole longComputation function into its own file and make it invoke that function when instructed via a message from the main process:

In a new compute.js file:
```js
const longComputation = () => {
  let sum = 0;
  for (let i = 0; i < 1e9; i++) {
    sum += i;
  };
  return sum;
};

process.on('message', (msg) => {
  const sum = longComputation();
  process.send(sum);
});
```

Now, instead of doing the long operation in the main process event loop,
we can fork the compute.js file and use the messages interface to communicate messages between the server and the forked process.
```js
const http = require('http');
const { fork } = require('child_process');

const server = http.createServer();

server.on('request', (req, res) => {
  if (req.url === '/compute') {
    const compute = fork('compute.js');
    compute.send('start');
    compute.on('message', sum => {
      res.end(`Sum is ${sum}`);
    });
  } else {
    res.end('Ok')
  }
});

server.listen(3000);
```
When a request to /compute happens now with the above code, we simply send a message to the forked process to start executing the long operation. 
The main processâ€™s event loop will not be blocked.

## [ä¸è¦é˜»å¡ä½ çš„äº‹ä»¶å¾ªç¯ï¼ˆæˆ–æ˜¯å·¥ä½œçº¿ç¨‹æ± ï¼‰](https://nodejs.org/zh-cn/docs/guides/dont-block-the-event-loop/)

Node.js æ˜¯ç”¨å¾ˆå°‘é‡çš„çº¿ç¨‹æ¥å¤„ç†å¤§é‡å®¢æˆ·ç«¯è¯·æ±‚çš„ã€‚ åœ¨ Node.js ä¸­ï¼Œæœ‰ä¸¤ç§ç±»å‹çš„çº¿ç¨‹ï¼šä¸€ä¸ªäº‹ä»¶å¾ªç¯çº¿ç¨‹ï¼ˆä¹Ÿè¢«ç§°ä¸ºä¸»å¾ªç¯ï¼Œä¸»çº¿ç¨‹ï¼Œäº‹ä»¶çº¿ç¨‹ç­‰ï¼‰ã€‚
å¦å¤–ä¸€ä¸ªæ˜¯åœ¨å·¥ä½œçº¿ç¨‹æ± é‡Œçš„ k ä¸ªå·¥ä½œçº¿ç¨‹ï¼ˆä¹Ÿè¢«ç§°ä¸ºçº¿ç¨‹æ± ï¼‰ã€‚

è¯·è®°ä½ï¼Œäº‹ä»¶å¾ªç¯çº¿ç¨‹åªè´Ÿè´£åè°ƒå®¢æˆ·ç«¯çš„è¯·æ±‚ï¼Œè€Œä¸æ˜¯ç‹¬è‡ªæ‰§è¡Œå®Œæ‰€æœ‰ä»»åŠ¡ã€‚ å¯¹ä¸€ä¸ªå¤æ‚çš„ä»»åŠ¡ï¼Œæœ€å¥½æŠŠå®ƒä»äº‹ä»¶å¾ªç¯çº¿ç¨‹è½¬ç§»åˆ°å·¥ä½œçº¿ç¨‹æ± ä¸Šã€‚

### é˜»å¡
å¦‚æœä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸€ä¸ªå›è°ƒå‡½æ•°ï¼ˆäº‹ä»¶è½®è¯¢çº¿ç¨‹ï¼‰æˆ–è€…ä»»åŠ¡ï¼ˆå·¥ä½œçº¿ç¨‹ï¼‰éœ€è¦è€—è´¹å¾ˆé•¿æ—¶é—´ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºâ€œé˜»å¡â€ã€‚ å½“ä¸€ä¸ªçº¿ç¨‹åœ¨å¤„ç†æŸä¸€ä¸ªå®¢æˆ·ç«¯è¯·æ±‚æ—¶è¢«é˜»å¡äº†ï¼Œå®ƒå°±æ— æ³•å¤„ç†å…¶å®ƒå®¢æˆ·ç«¯çš„è¯·æ±‚äº†ã€‚ è¿™é‡Œç»™å‡ºä¸¤ä¸ªä¸èƒ½é˜»å¡äº‹ä»¶è½®è¯¢çº¿ç¨‹å’Œå·¥ä½œçº¿ç¨‹çš„ç†ç”±ï¼š

- æ€§èƒ½ï¼šå¦‚æœä½ åœ¨ä»»æ„ç±»å‹çš„çº¿ç¨‹ä¸Šé¢‘ç¹å¤„ç†ç¹é‡çš„ä»»åŠ¡ï¼Œé‚£ä¹ˆä½ çš„æœåŠ¡å™¨çš„ ååé‡ï¼ˆè¯·æ±‚/ç§’ï¼‰å°†é¢ä¸´ä¸¥å³»è€ƒéªŒã€‚
- å®‰å…¨æ€§ï¼šå¦‚æœå¯¹äºç‰¹å®šçš„è¾“å…¥ï¼Œä½ çš„æŸç§ç±»å‹çš„çº¿ç¨‹å¯èƒ½ä¼šè¢«é˜»å¡ï¼Œé‚£ä¹ˆæ¶æ„æ”»å‡»è€…å¯ä»¥é€šè¿‡æ„é€ ç±»ä¼¼è¿™æ ·çš„â€œæ¶æ„è¾“å…¥â€ï¼Œæ•…æ„è®©ä½ çš„çº¿ç¨‹é˜»å¡ï¼Œç„¶åä½¿å…¶å®ƒå®¢æˆ·ç«¯è¯·æ±‚å¾—ä¸åˆ°å¤„ç†ã€‚è¿™å°±æ˜¯æ‹’ç»æœåŠ¡æ”»å‡»ã€‚


## NodeJS ä½¿ç”¨åœºæ™¯

ä¼˜ç‚¹ï¼šé«˜å¹¶å‘ï¼ˆæœ€é‡è¦çš„ä¼˜ç‚¹ï¼‰ã€é€‚åˆ I/O å¯†é›†å‹åº”ç”¨
```
å½“ä½ è¯´Node.JSå¯ä»¥å¤„ç†10,000ä¸ªå¹¶å‘è¯·æ±‚æ—¶ï¼Œå®ƒä»¬æœ¬è´¨ä¸Šæ˜¯éé˜»å¡è¯·æ±‚ï¼Œå³è¿™äº›è¯·æ±‚ä¸»è¦ä¸æ•°æ®åº“æŸ¥è¯¢æœ‰å…³ã€‚
```

ç¼ºç‚¹ï¼š
1. ä¸é€‚åˆCPUå¯†é›†å‹åº”ç”¨ï¼ˆCPUå¯†é›†å‹åº”ç”¨ç»™Nodeå¸¦æ¥çš„æŒ‘æˆ˜ä¸»è¦æ˜¯ï¼šç”±äºJavaScriptå•çº¿ç¨‹çš„åŸå› ï¼Œå¦‚æœæœ‰é•¿æ—¶é—´è¿è¡Œçš„è®¡ç®—ï¼ˆæ¯”å¦‚å¤§å¾ªç¯ï¼‰ï¼Œ
   å°†ä¼šå¯¼è‡´ CPU æ—¶é—´ç‰‡ä¸èƒ½é‡Šæ”¾ï¼Œä½¿å¾—åç»­ I/O æ— æ³•å‘èµ·ï¼‰

è§£å†³æ–¹æ¡ˆï¼šè¿™ä¸ªä¸æ˜¯æ­£ç¡®çš„è§’åº¦ï¼ï¼ï¼ è¿™é‡Œæ˜¯è¦è§£å†³CPUå¯†é›†å‹çš„é—®é¢˜ï¼Œéœ€è¦æŠŠCPUå¯†é›†å‹ä»»åŠ¡ä»event loopçº¿ç¨‹æ‹¿å‡ºå»
```
ï¼ˆ1ï¼‰Nnigx åå‘ä»£ç†ï¼Œè´Ÿè½½å‡è¡¡ï¼Œå¼€å¤šä¸ªè¿›ç¨‹ï¼Œç»‘å®šå¤šä¸ªç«¯å£ï¼›
ï¼ˆ2ï¼‰å¼€å¤šä¸ªè¿›ç¨‹ç›‘å¬åŒä¸€ä¸ªç«¯å£ï¼Œä½¿ç”¨clusteræ¨¡å—
ï¼ˆ3ï¼‰çº¿ä¸Šä½¿ç”¨ PM2 ç®¡ç†è¿›ç¨‹ï¼Œå‡ºç°é—®é¢˜è‡ªåŠ¨é‡å¯é¡¹ç›®
```

å¯ä»¥ä½¿ç”¨Node.js çš„child process,  worker_thread
é‚£ä¹ˆå“ªç§ç¼–ç¨‹è¯­è¨€å¯ä»¥ç”¨ä»€ä¹ˆæ ·çš„æ–¹å¼æ¯”è¾ƒå¥½çš„å¤„ç†CPUå¯†é›†å‹çš„æƒ…æ™¯ï¼Ÿ



## å„ç§ç¼–ç¨‹è¯­è¨€å¤„ç†å¹¶å‘çš„æ–¹å¼
[What makes the Single Threaded Event Loop Model Efficient?](https://blog.soshace.com/advanced-node-js-a-hands-on-guide-to-event-loop-child-process-and-worker-threads-in-node-js/)

To better understand what problem Node.js solves we should look at the what typical web servers were like before Node.js came into play.

This is how a traditional multi-threaded web application model handles request:

- It maintains a thread pool (a collection of available threads)
- When client request comes in a thread is assigned
- This thread will take care of reading Client requests, processing Client requestS, performing any Blocking IO Operations (if required) and preparing Response.
- This thread is not free until a response is sent back

è¿™ç§æ¨¡å‹æœ€å¤§çš„ç¼ºç‚¹å°±æ˜¯æœ‰å¤§é‡å¹¶å‘è¿æ¥çš„æ—¶å€™çº¿ç¨‹æ¯ç«­ï¼Œåæ¥çš„ç”¨æˆ·éœ€è¦ç­‰å¾…å‰è¾¹ç”¨æˆ·çš„çº¿ç¨‹é‡Šæ”¾è¿›è€Œè·å¾—å“åº”ã€‚
Moreover, the server itself start to slow down because of increasing load. Thereâ€™s also the overhead of context switching between threads and writing applications to optimize threads resource sharing can be painful.

What happens when you run a Node.js Program?
when we run our Node.js app it creates

1. Process ğŸ¤–
2. Thread ğŸ§µ
3. Event Loop â°

The single-threaded event loop architecture uses resources efficiently,
it doesnâ€™t need to spin off new threads for every single request.Node.js also delegates blocking tasks to other components as we saw earlier. Since we donâ€™t really care about many threads it makes node.js very lightweight and ideal for microservice-based architecture.
![event loop](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-2-1.jpg)

### Drawbacks of Nodeâ€™s Single Threaded Model !!!
This is 2020 ğŸ˜„ and we are seeing more and more complicated web applications. What if our application needs to do complex computation, run a machine learning algorithm? Or What if we want to run a complicated crypto algorithm? In this case we have to harness the power of multiple cores to increase performance.

Languages like Java and C# can programmatically initiate threads and harness the power of multiple cores. In Node.js that is not an option as we saw earlier. Nodeâ€™s way of solving this problem is child_process.
![child](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-3-1.jpg)

In 2018 Node.js introduced worker_thread. This module allows node the ability to have

1. Process
Multiple threads
2. Event Loop per thread
Yes!! You read that right ğŸ˜„.

![worker](https://soshace-12d3e.kxcdn.com/wp-content/uploads/2020/01/component-4-1.jpg)

As of January 2020 worker_threads are fully supported in the Node LST version 12. I highly recommend reading up the following post if you want to learn more about worker_threads.

[Node.js multithreading](https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10/)

### Node.js
["I/O" ä¸»è¦æŒ‡ç”±libuvæ”¯æŒçš„ï¼Œä¸ç³»ç»Ÿç£ç›˜å’Œç½‘ç»œä¹‹é—´çš„äº¤äº’](https://nodejs.org/zh-cn/docs/guides/blocking-vs-non-blocking/)
libuv - Cross-platform asynchronous I/O 

- Full-featured event loop backed by epoll, kqueue, IOCP, event ports.
- Asynchronous file and file system operations
- IPC with socket sharing, using Unix domain sockets or named pipes (Windows)
- Child processes


### java

### Golang

## Apache çš„å¤šçº¿ç¨‹é«˜å¹¶å‘æ¨¡å¼
ä¼˜ç‚¹ï¼šæ”¯æŒå¤šçº¿ç¨‹å¹¶å‘

ç¼ºç‚¹ï¼šé˜»å¡


## é™„å½•
### What do the terms â€œCPU boundâ€ and â€œI/O boundâ€ mean?:
- CPU Bound means the rate at which process progresses is limited by the speed of the CPU.
A task that performs calculations on a small set of numbers, for example multiplying small matrices, is likely to be CPU bound.
A program is CPU bound if it would go faster if the CPU were faster.

- CPU å¯†é›†å‹æ„å‘³ç€å¤„ç†ä»»åŠ¡çš„é€Ÿåº¦æ˜¯ç”±CPUçš„é€Ÿåº¦é™åˆ¶çš„ï¼Œä¸€èˆ¬æ˜¯è®¡ç®—å‹çš„åº”ç”¨ï¼Œå¦‚æœCPUè¿è¡Œé€Ÿåº¦è¶Šå¿«ï¼Œåº”ç”¨ç¨‹åºè¶Šå¿«é‚£å°±æ˜¯CPUå¯†é›†å‹åº”ç”¨ã€‚

- I/O Bound means the rate at which a process progresses is limited by the speed of the I/O subsystem.
A task that processes data from disk, for example, counting the number of lines in a file is likely to be I/O bound.
A program is I/O bound if it would go faster if the I/O subsystem was faster.

- I/O å¯†é›†å‹æ„å‘³ç€ç¨‹åºè¿è¡Œé€Ÿç‡ç”±I/Oå­ç³»ç»Ÿçš„é€Ÿåº¦é™åˆ¶ï¼Œä»ç¡¬ç›˜ä¸Šè¯»å†™æ•°æ®æˆ–è€…è®¡ç®—ä¸€ä¸ªæ–‡ä»¶çš„è¡Œæ•°å±äºI/Oå‹æ“ä½œã€‚

### I/O-bound vs CPU-bound in Node.js
https://bytearcher.com/articles/io-vs-cpu-bound/

Bound implies performance bottleneck 
Bound æ„å‘³ç€æ€§èƒ½ç“¶é¢ˆ

I/O-bound application waits most of the time for network, filesystem and database.
I/O-bound å‹åº”ç”¨æ¶ˆè€—å¤§é‡æ—¶é—´åœ¨ ç½‘ç»œè¿æ¥ã€æ–‡ä»¶ç³»ç»Ÿã€æ•°æ®åº“è¯»å†™ã€‚

CPU bound
This kind of application leads to trouble in Node.js. If the application spends too much time performing CPU intensive task all other requests are being held up. 
CPU bound å‹åº”ç”¨å¯¼è‡´Node.jsåº”ç”¨å‡ºç°é—®é¢˜ã€‚å¦‚æœæ¶ˆè€—å¤§é‡æ—¶é—´ç”¨äºCPUå ç”¨ç‡é«˜çš„ä»»åŠ¡ï¼Œé‚£ä¹ˆæ‰€æœ‰å…¶ä»–è¯·æ±‚å°†ä¼šè¢«æŒ‚èµ·ã€‚

A typical healthy Node.js server application is I/O bound. That is what Node.js was designed for and handles well using the single-threaded event loop. 
ä¸€ä¸ªå¥åº·çš„Node.jsæœåŠ¡åº”è¯¥æ˜¯I/Oå¯†é›†å‹çš„ï¼Œè¿™ä¹Ÿæ˜¯ä½¿ç”¨å•çº¿ç¨‹çš„äº‹ä»¶å¾ªç¯æ¨¡å‹è®¾è®¡çš„åˆè¡·ã€‚




